import syssys.path.append('..')import config.Config as Cfgimport ConstResource as Resimport FunctionCommon as FunComdef parse_case_config(conf):    case = Cfg.SMCase()    pkg = conf.get(Cfg.SMSet.INSPECT, Cfg.SMCaseKey.PKG)    pro = conf.get(Cfg.SMSet.INSPECT, Cfg.SMCaseKey.PROCESS)    act = conf.get(Cfg.SMSet.INSPECT, Cfg.SMCaseKey.TO_START_ACTIVITY)    apk = conf.get(Cfg.SMSet.INSPECT, Cfg.SMCaseKey.TO_INSTALL_APK)    has_nav = conf.get(Cfg.SMSet.CASE_RULES, Cfg.SMKey.STANDARD_HAS_NAVIGATION_BAR)    nav_height = int(conf.get(Cfg.SMSet.CASE_RULES, Cfg.SMKey.STANDARD_NAVIGATION_BAR_HEIGHT))    x = int(conf.get(Cfg.SMSet.CASE_RULES, Cfg.SMKey.DISPLAY_SIZE_X))    y = int(conf.get(Cfg.SMSet.CASE_RULES, Cfg.SMKey.DISPLAY_SIZE_Y))    case.common = Cfg.SMCommon(pkg, pro, act, apk, x, y, has_nav, nav_height)    case_items = conf.items(Cfg.SMSet.CASE)    for i in range(len(case_items)):        repeat = int(case_items[i][1])        if repeat > 0:            case.tasks.append(case_items[i])    return casedef parse_info_file_full_path(tag, config_file=Res.parsed_device_info_file):    phone_path = FunCom.linux_path_join(Res.parsed_device_info_file_path, config_file)    tagged_phone_info_file_name = FunCom.parse_model(tag) + tag + '_' + Res.parsed_device_info_file    info_dir = FunCom.path_join(Res.project_path, FunCom.path_join(Res.output_path_name                                                                   , Res.phone_info_dir_name))    FunCom.make_dir_if_not_exist(FunCom.get_abspath(info_dir))    info_file_path = FunCom.path_join(info_dir, tagged_phone_info_file_name)    FunCom.p_open(Res.asb_shell_pull_log_file(tag, info_file_path, phone_path))    return info_file_pathdef parse_navigation_height(tag, config_file=Res.parsed_device_info_file):    info_file_path = parse_info_file_full_path(tag, config_file)    lines = FunCom.get_usable_lines_from_file(info_file_path, True)    info = [0, 0, 0]    for line in lines:        if Res.key_navigation_bar_height in line:            info[0] = parse_item_value(line)        elif Res.key_display_size_x in line:            info[1] = parse_item_value(line)        elif Res.key_display_size_y in line:            info[2] = parse_item_value(line)    return info[0], info[1], info[2]def parse_item_value(line):    assert len(line) > 1    return int(line.split('=')[1])def device_portrait(tag):    """    This can be done through the following command:        adb shell dumpsys input | grep 'SurfaceOrientation' | awk '{ print $2 }'    The output will be an integer ranging from 0 to 3 for each of the four possible orientations.    0 and 2 are portrait while 1 and 3 are landscape. As the dumpsys output is very large,    the command might take a few seconds to complete.    :param tag:    :return:    """    orientation = FunCom.p_open_with_line_1_result(Res.adb_orientation(tag))    return int(orientation) % 2 == 0def device_screen_size(tag):    """    adb shell dumpsys window | grep cur= |tr -s " " | cut -d " " -f 4|cut -d "=" -f 2    :param tag:    :return:    """    screen_size = FunCom.p_open_with_line_1_result(Res.adb_screen_size(tag))    w_h = screen_size.split('x')    return int(w_h[0]), int(w_h[1])def device_real_config_info(tag):    """    real display size, deduce nav_height if has a nav bar    :param tag:    :return:    """    nav_height, w, h = parse_navigation_height(tag)    # comment portrait parsing for    # portrait = device_portrait(tag)    real_w = w    real_h = h - nav_height    return real_w, real_h, nav_height