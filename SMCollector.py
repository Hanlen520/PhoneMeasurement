from multiprocessing import freeze_supportimport ConstResource as Resimport FunctionCommon as FunComimport FunctionPackage as FunPkgimport config.Config as Cfgimport config.ConfigHelper as CfgHelperfrom util.Util import SM as SMfrom core import MultiProcessDEBUG = Truedef sm_auto_collect():    devices = FunCom.devices_list_with_connection_check()    devices_count = len(devices)    if devices_count <= 0:        FunCom.raise_error('No device connected, check connections!!!')        return    # parse configure    conf = FunCom.get_conf_parser(Cfg.sm_collector_conf_file)    FunCom.assert_options_presents(conf, [Cfg.SMSet.INSPECT, Cfg.SMSet.CASE, Cfg.SMSet.CASE_RULES,                                          Cfg.SMSet.SETTING])    setting_mode = conf.get(Cfg.SMSet.SETTING, Cfg.SMKey.MODE)    setting_threshold = conf.get(Cfg.SMSet.SETTING, Cfg.SMKey.SPLIT_THRESHOLD)    case_config = CfgHelper.parse_case_config(conf)    to_run_case_count = len(case_config.tasks)    if to_run_case_count == 0:        FunCom.raise_error(            'No case to run, set at least 1 case to run! See more in ' + Cfg.sm_collector_conf_file)        return    case_configs, separately = assemble_configs_for_devices(case_config, devices_count,                                                            setting_mode,                                                            setting_threshold,                                                            to_run_case_count)    MultiProcess.run(sm_collect_flow_control, separately, *case_configs)def assemble_configs_for_devices(case_config, devices_count, setting_mode, setting_threshold,                                 to_run_case_count):    # assemble configs for devices    case_configs = [case_config]    run_separately = False    # more than one device, split cases if set to split mode    if devices_count > 1 and int(setting_mode) != 0 and to_run_case_count > int(setting_threshold):        average_case = to_run_case_count / devices_count        left_case_count = to_run_case_count % devices_count        del case_configs[:]        run_separately = True        for i in range(devices_count):            cfg = Cfg.SMCase(case_config.common)            for j in range(average_case + (                    left_case_count if left_case_count > 0 and i == devices_count - 1 else 0)):                to_run_index = case_config.tasks[j + i * average_case]                cfg.tasks.append(to_run_index)            case_configs.append(cfg)    return case_configs, run_separatelydef sm_collect_flow_control(tag, cfg):    if not isinstance(cfg, Cfg.SMCase):        assert len(cfg) > 0        cfg = cfg[0]    installed_before = True    # install sm collector app    if not FunCom.tell_app_installed(tag, SM.pkg):        installed_before = False        FunPkg.install_app_start_activity(tag, SM.pkg, SM.act, SM.apk_file_keyword)    # start main activity to init    start_sm_act_cmd = Res.asb_shell_start_activity(tag, SM.act)    FunCom.p_open(start_sm_act_cmd)    # ask user to assign root permission    # if not installed_before:    #     FunCom.sleep(5)    FunCom.send_key_back(tag)    for i in range(len(cfg.tasks)):        task_name = cfg.tasks[i][0]        f = Res.case_file_pattern % task_name        for j in range(int(cfg.tasks[i][1])):            FunCom.log('--running in case \'%s\' times:%s' % (task_name, i + j))            start_sm_inspect_by_case(tag, cfg.common, task_name, j, start_sm_act_cmd, f)            # sleep one period            FunCom.sleep(5)        FunCom.log('pull stored file into \'output\' directory in project directory')        out_path = FunCom.path_join(Res.project_path, FunCom.path_join(            Res.output_path_name, FunCom.parse_model(tag) + '_' + tag))        FunCom.p_open(Res.asb_shell_pull_log_file(tag, out_path, SM.store_path_on_phone))def start_sm_inspect_by_case(tag, common, folder_tag, name_tag, start_sm, case_file=Res.case_file):    # start SM inspect    FunCom.log(case_file)    special_mode = FunCom.case_file_special(case_file)    broadcast_on_str = Res.asb_shell_broadcast(tag, SM.on_action) \                       + SM.extra_pkg % common.pkg \                       + SM.extra_pro % common.pro \                       + SM.extra_file % name_tag \                       + SM.extra_folder % folder_tag \                       + SM.extra_wait_process % 'true'    off_str = Res.asb_shell_broadcast(tag, SM.off_action)    commands = [broadcast_on_str, off_str, start_sm]    if not special_mode:        FunCom.p_open(broadcast_on_str)        FunCom.sleep(10 if not DEBUG else 0, 'wait sm collector initialization to complete')        FunCom.serial_operation_by_control_file(tag, case_file, common, commands)        FunCom.log('stop SM inspect, store file')        FunCom.p_open(off_str)        FunCom.sleep(4 if not DEBUG else 0, 'sleep to wait for finishing process')    else:        FunCom.serial_operation_by_control_file(tag, case_file, common, commands)if __name__ == '__main__':    freeze_support()    sm_auto_collect()