import osimport timefrom time import gmtime, strftimetime_format = "%Y-%m-%d-%H-%M-%S"adb_s = 'adb -s 'shell_start_activity_command = ' shell am start -n 'shell_find_file = ' shell ls %s'shell_ps_grep = ' shell ps |grep %s'grep_process = 'ps ax | grep %s'force_stop = ' shell am force-stop %s'pm_clear = ' shell pm clear %s'unix_nohup = 'nohup %s &'def get_file_in_directory_full_path(f):    return os.path.dirname(os.path.realpath(__file__)) + '/' + fdef current_time(t_format=time_format):    return strftime(t_format, gmtime())def print_info(info):    print current_time() + ': ' + str(info)def log(*info):    for c in info:        if isinstance(c, list):            for cc in c:                print_info(cc)        elif isinstance(c, str):            print_info(c)def p_open(command):    log('COMMAND: ' + command)    return os.popen(command)def sleep(seconds, log_info=''):    log('sleep for seconds: ' + str(seconds) + ', ' + log_info)    time.sleep(seconds)def p_open_with_line_1_result(command):    lines = p_open(command).readlines()    return lines[0].strip() if lines.__len__() > 0 else Nonedef p_open_with_all_results(command):    return p_open(command).readlines()def tell_process_running(d, pro):    ps_res = p_open_with_all_results(adb_grep_process(d, pro))    return target_in_list_content(pro, ps_res)def clear_date_force_stop(d, pro):    clear_app_data(d, pro)    force_stop_app(d, pro)def clear_app_data(d, pro):    p_open(adb_force_stop_process(d, pro))def force_stop_app(d, pro):    p_open(adb_force_stop_process(d, pro))def target_in_list_content(target, ls):    for l in ls:        if target in l:            return True    return Falsedef adb_s_tag_prefix(tag):    return adb_s + str(tag)def asb_shell_start_activity(tag, act_name):    return adb_s_tag_prefix(tag) + start_activity_str(act_name)def start_activity_str(activity):    return shell_start_activity_command + activitydef find_file(d, f):    return adb_s_tag_prefix(d) + shell_find_file % fdef adb_grep_process(d, process):    return adb_s_tag_prefix(d) + shell_ps_grep % processdef adb_force_stop_process(d, process):    return adb_s_tag_prefix(d) + force_stop % processdef adb_pm_clear_process(d, process):    return adb_s_tag_prefix(d) + pm_clear % processdef exe_py_in_background_if_not_running(py_name, background=True):    lines = p_open_with_all_results(grep_process % py_name)    execute_cmd = 'python ' + get_file_in_directory_full_path(py_name)    for line in lines:        if execute_cmd in line:            return    execute_cmd = (unix_nohup % execute_cmd) if background else execute_cmd    osc(execute_cmd)def exe_ignore_error(c):    log('processing command:' + c)    try:        os.system(c)    except BaseException as be:        log(be)        passdef osc(*cmd):    for c in cmd:        if isinstance(c, list):            for cc in c:                exe_ignore_error(cc)        elif isinstance(c, str):            exe_ignore_error(c)if __name__ == '__main__':    osc('pwd')    osc('pwd', 'pwd')    osc(['pwd', 'pwd'], 'pwd')